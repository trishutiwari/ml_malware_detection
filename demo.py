#!/usr/bin/env python3

import logging
logging.getLogger("scapy.runtime").setLevel(logging.ERROR)
import warnings
warnings.filterwarnings("ignore")

print("Preparing the GPU...................")
import keras as keras
import time
import datetime
from keras.models import Sequential
from keras.layers import Dense
import numpy as np 
from nn import *
import sys
import matplotlib.pyplot as plt 
import matplotlib
import random

def get_formatted_data():
	print("############ FORMATTING THE DATA ############")
	malware_name_list = ['zeus','conflickerdemo','dridexdemo']
	end_index_list = [2,2,2]
	data, classes = retrieve_datasets(malware_name_list,end_index_list)
	# print(data)
	return data, classes

def plot_confusion_matrix(cm, title='Confusion matrix', cmap=plt.cm.Blues, labels=[]):
	matplotlib.use('QT4Agg')
	plt.imshow(cm, interpolation='nearest', cmap=cmap)
	plt.title(title)
	plt.colorbar()
	tick_marks = np.arange(len(labels))
	plt.xticks(tick_marks, labels, rotation=45)
	plt.yticks(tick_marks, labels)
	plt.tight_layout()
	plt.ylabel('True label')
	plt.xlabel('Predicted label')
	# plt.safefig(title, dpi=NONe)
	plt.savefig(title+ " " + "demo" + "01" + '.png')


def load_weights_predict(filename,evaluate_data,evaluate_classes):
	arrayDataLength = 133
	numInputs = arrayDataLength 
	activation_func = "sigmoid"
	neuralNetModel = Sequential()
	neuralNetModel.add(Dense(1000, input_dim=numInputs, activation=activation_func))
	neuralNetModel.add(Dense(3, activation=activation_func)) 
	neuralNetModel.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])
	print("############ LOADING THE WEIGHTS FROM "+ filename+" #############")
	neuralNetModel.load_weights(filename)
	neuralNetModel.summary() 

	print("############ EVALUATING USING THE MODEL ############")
	evaluated_loss, evaluated_accuracy = neuralNetModel.evaluate(evaluate_data,evaluate_classes,arrayDataLength,verbose=1)
	print("LOSS: "+ str(evaluated_loss))
	print("ACCURACY: "+ str(evaluated_accuracy))
	# # Plot confusion matrix
	test_Y_hat = neuralNetModel.predict(evaluate_data, batch_size=100)
	conf = np.zeros([3,3])
	confnorm = np.zeros([3,3])
	for i in range(0,evaluate_data.shape[0]):
	    j = list(evaluate_classes[i,:]).index(1)
	    k = int(np.argmax(test_Y_hat[i,:]))
	    conf[j,k] = conf[j,k] + 1
	for i in range(0,3):
	    confnorm[i,:] = conf[i,:] / np.sum(conf[i,:])
	the_classes = ['zeus', 'conficker', 'dridex']
	plot_confusion_matrix(confnorm, labels=the_classes)



if __name__ == "__main__":
	filename = "Weights_sigmoid_2017_12_08_22_05.h5"
	print("THE GIVEN WEIGHTS FILENAME IS: "+ filename)
	print("=======================================================================")
	print("")
	print("The Activation Function using for this test is SIGMOID")
	print("")

	# evaluate_data, theClasses = get_formatted_data()
	# np.save("evaluateData",evaluate_data)
	# np.save("evaluateClasses", theClasses)
	# print(theClasses)
	theData = np.load("evaluateData.npy")
	theLabels = np.load("evaluateClasses.npy")
	classType = [0, 0, 0, 0]
	for i in theLabels: 
		if i == 0:
			classType[0] += 1
		if i == 1: 
			classType[1] += 1
		if i == 2: 
			classType[2] += 1
		if i == 3:
			classType[3] += 1
	zeus = theLabels[:classType[0]]
	conficker = theLabels[classType[0]:classType[1]]
	dridex = theLabels[classType[1]+classType[0]:]

	zeusD = theData[0:len(zeus)] 
	confickerD = theData[classType[0]:classType[0] + len(zeus)]  
	dridexD = theData[classType[0] + classType[1]:]
	zeus = zeus[0:len(zeus)]
	conficker = conficker[0:len(zeus)]

	indices = random.sample(range(0,len(zeus)), int(len(zeus)))

	trainZeus = zeusD[indices]
	trainConficker = confickerD[indices]
	trainDridex = dridexD[indices]
	tLZ = zeus[indices]
	tLC = conficker[indices]
	tLD = dridex[indices]

	evaluate_data = np.concatenate((trainZeus, trainConficker, trainDridex), axis=0)
	theLabels = np.concatenate((tLZ, tLC, tLD), axis=0)
	# load_weights_predict(filename,evaluate_data,theLabels)
	# classTypes = [0, 0, 0]
	# for i in classes: 
	# 	if i == 0: 
	# 		classTypes[0] += 1
	# 	if i == 1: 
	# 		classTypes[1] += 1
	# 	if i == 2: 
	# 		classTypes[2] += 1

	# print("Zeus: ",classTypes[0])
	# print("Conficker: ",classTypes[1])
	# print("Dridex: ",classTypes[2])
	# print(classes)
	# print(classes[4])
	# print(classes[5])


	evaluate_classes = keras.utils.to_categorical(theLabels, num_classes=3)
	
	load_weights_predict(filename,evaluate_data,evaluate_classes)

	

