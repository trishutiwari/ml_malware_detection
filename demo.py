print("Preparing the GPU...................")
import keras as keras
import time
import datetime
from keras.models import Sequential
from keras.layers import Dense
import numpy as np 
from nn import *
import sys
import matplotlib.pyplot as plt 
import matplotlib

def get_formatted_data():
	print("############ FORMATTING THE DATA ############")
	malware_name_list = ['zeus','conflickerdemo','dridexdemo','tridemo']
	end_index_list = [2,2,2,2]
	data, classes = retrieve_datasets(malware_name_list,end_index_list)
	# print(data)
	return data, classes

def plot_confusion_matrix(cm, title='Confusion matrix', cmap=plt.cm.Blues, labels=[]):
	matplotlib.use('QT4Agg')
	plt.imshow(cm, interpolation='nearest', cmap=cmap)
	plt.title(title)
	plt.colorbar()
	tick_marks = np.arange(len(labels))
	plt.xticks(tick_marks, labels, rotation=45)
	plt.yticks(tick_marks, labels)
	plt.tight_layout()
	plt.ylabel('True label')
	plt.xlabel('Predicted label')
	# plt.safefig(title, dpi=NONe)
	plt.savefig(title+'.png')


def load_weights_predict(filename,evaluate_data,evaluate_classes):
	arrayDataLength = 133
	numInputs = arrayDataLength 
	activation_func = "sigmoid"
	neuralNetModel = Sequential()
	neuralNetModel.add(Dense(3000, input_dim=numInputs, activation=activation_func))
	neuralNetModel.add(Dense(3, activation=activation_func)) 
	neuralNetModel.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])
	print("############ LOADING THE WEIGHTS FROM "+ filename+" #############")
	neuralNetModel.load_weights(filename)
	neuralNetModel.summary() 

	print("############ EVALUATING USING THE MODEL ############")
	# evaluated_loss, evaluated_accuracy = neuralNetModel.evaluate(evaluate_data,evaluate_classes,arrayDataLength,verbose=1)
	# print("LOSS: "+ str(evaluated_loss))
	# print("ACCURACY: "+ str(evaluated_accuracy))
	# # Plot confusion matrix
	test_Y_hat = neuralNetModel.predict(evaluate_data, batch_size=200)
	conf = np.zeros([3,3])
	confnorm = np.zeros([3,3])
	for i in range(0,evaluate_data.shape[0]):
	    j = list(evaluate_classes[i,:]).index(1)
	    k = int(np.argmax(test_Y_hat[i,:]))
	    conf[j,k] = conf[j,k] + 1
	for i in range(0,3):
	    confnorm[i,:] = conf[i,:] / np.sum(conf[i,:])
	the_classes = ['zeus', 'conficker', 'dridex']
	plot_confusion_matrix(confnorm, labels=the_classes)



if __name__ == "__main__":
	filename = "Weights_sigmoid_2017_12_03_11_30.h5"
	print("THE GIVEN WEIGHTS FILENAME IS: "+ filename)
	print("=======================================================================")
	print("")
	print("The Activation Function using for this test is SIGMOID")
	print("")

	# evaluate_data, theClasses = get_formatted_data()
	# np.save("evaluateData",evaluate_data)
	# np.save("evaluateClasses", theClasses)
	# print(theClasses)
	evaluate_data = np.load("evaluateData.npy")
	theLabels = np.load("evaluateClasses.npy")
	theIndex = np.where(theLabels == 3)
	print("First item: ",theIndex[0][0])
	classes = np.reshape(theLabels[:theIndex[0][0]], (len(theLabels[:theIndex[0][0]]), 1))
	classTypes = [0, 0, 0]
	for i in classes: 
		if i == 0: 
			classTypes[0] += 1
		if i == 1: 
			classTypes[1] += 1
		if i == 2: 
			classTypes[2] += 1

	print("Zeus: ",classTypes[0])
	print("Conficker: ",classTypes[1])
	print("Dridex: ",classTypes[2])
	# print(classTypes[0])
	# print(classTypes[1])
	# print(classTypes[2])


	# evaluate_classes = keras.utils.to_categorical(classes, num_classes=3)
	# evaluate_data = evaluate_data[:theIndex[0][0]]
	
	# load_weights_predict(filename,evaluate_data,evaluate_classes)

	

